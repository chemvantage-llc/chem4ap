/*  ChemVantage - A Java web application for online learning
 *   Copyright (C) 2011 ChemVantage LLC
 *   
 *    This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.chemvantage.chem4ap;

import static com.googlecode.objectify.ObjectifyService.ofy;
import static com.googlecode.objectify.ObjectifyService.key;

import java.util.Date;
import java.util.List;
import java.util.Random;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;

/**
 * User entity representing an LTI-authenticated user or anonymous ChemVantage visitor.
 * 
 * Users are persisted temporarily (90 minutes) and identified via hashed values to support
 * question attempts, score tracking, and report generation. Two user types are supported:
 * 
 * LTI Users (authenticated from Learning Management System):
 * - Identified by platformId (LMS URL) and userId combination
 * - Authenticated via LTI 1.3 protocol
 * - May have instructor/admin roles for content authoring
 * - Associated with specific assignments for grading
 * - Support role-based access control (student, contributor, TA, instructor, admin)
 * 
 * Anonymous Users (direct web access):
 * - Session-based with 90-minute expiration
 * - Identified via hashed temporary credentials
 * - No persistent role assignments
 * - Useful for practice/trial access
 * 
 * Security Notes:
 * - IDs are encrypted with one-time pad before storage (weak but prevents casual inspection)
 * - Encryption seed (sig) is ephemeral - decryption only possible while User entity exists (~1 day)
 * - Hashed IDs provide secondary identifier for data linkage without exposing original IDs
 * 
 * @see Score for student performance tracking
 * @see PremiumUser for subscription status
 */
@Entity
public class User {
	// User expiration constants
	private static final long DEFAULT_EXPIRATION_MILLIS = 5400000L;  // 90 minutes
	private static final int DEFAULT_EXPIRATION_MINUTES = 90;
	private static final int MAX_EXPIRATION_MINUTES = 500;
	private static final int GRACE_PERIOD_MINUTES = 5;
	private static final long MILLIS_PER_MINUTE = 60000L;
	
	// Role bit masks for permission checking
	private static final int ROLE_CONTRIBUTOR = 1;      // Bit 0: Can create/edit questions
	private static final int ROLE_TEACHING_ASSISTANT = 4;   // Bit 2: Can manage assignments
	private static final int ROLE_INSTRUCTOR = 8;       // Bit 3: Can grade and manage roster
	private static final int ROLE_ADMINISTRATOR = 16;   // Bit 4: Can manage site content
	private static final int ROLE_CHEMVANTAGE_ADMIN = 32;    // Bit 5: ChemVantage super-admin
	private static final int ROLE_BITMASK = 63;         // All roles: 0b111111
	
	// Encryption parameters
	private static final int ENCRYPT_RANDOM_RANGE = 128;     // 0-127 random values
	private static final String ANONYMOUS_PREFIX = "anonymous";
	
	// Field visibility and indexing
	/** Unique identifier for this User (autogenerated from datastore) */
	@Id 	Long 	sig;
	
	/** Hashed user identifier for secure data linkage across entities */
	@Index 	String  hashedId;
	
	/** Session expiration date (typically 90 minutes from creation) */
	@Index	Date 	exp;
	
	/** Encrypted user ID (encrypted with sig as seed for one-time pad) */
	@Index	String  encryptedId;
	
	/** Platform/LMS URL identifier for LTI users; null for anonymous */
			String	platformId;
	
	/** Associated assignment ID (for LTI Advantage grade services) */
	@Index	long	assignmentId = 0L;
	
	/** User roles and permissions bitmask (see ROLE_* constants) */
			int 	roles = 0;
	
	/**
	 * Default constructor for anonymous users.
	 * 
	 * Creates a new anonymous user session with 90-minute expiration.
	 * The session is identified by an encoded expiration timestamp and cannot be persisted.
	 */
	User() {
		long millis = new Date().getTime() + DEFAULT_EXPIRATION_MILLIS;
		sig = encode(millis);
		encryptedId = ANONYMOUS_PREFIX + String.valueOf(millis).hashCode();
		hashedId = Util.hashId(encryptedId);
	}

	/**
	 * Constructor for independent student users (non-LTI).
	 * 
	 * Checks if a user with this email already exists and reuses the sig/hashedId if found.
	 * Otherwise creates a new independent user profile.
	 * 
	 * @param email the user's email address (combined with server URL for user_id)
	 */
	User(String email) {
		this.platformId = Util.getServerUrl();
		String user_id = platformId + "/" + email;
		this.encryptedId = encryptId(user_id,0L);  // temporary until sig is assigned in setToken()
		try {
			User user = ofy().load().type(User.class).filter("encryptedId",encryptedId).first().safe();
			this.sig = user.sig;
			this.hashedId = user.hashedId;
		} catch (Exception e) {
			this.hashedId = Util.hashId(user_id);
		}
		this.exp = new Date(new Date().getTime() + DEFAULT_EXPIRATION_MILLIS);
	}
	
	/**
	 * Constructor for LTI 1.3 authenticated users.
	 * 
	 * Creates a new user entity from LTI platform and user ID information.
	 * Does not persist to database until setToken() is called.
	 * 
	 * @param platformId the LMS platform URL from LTI iss claim
	 * @param id the user ID from LTI sub claim (null is converted to empty string)
	 */
	User(String platformId, String id) {
		this.platformId = platformId;
		if (id == null) id = "";
		String user_id = platformId==null?id:platformId + "/" + id;
		this.hashedId = Util.hashId(user_id);
		this.exp = new Date(new Date().getTime() + DEFAULT_EXPIRATION_MILLIS);
		this.encryptedId = encryptId(user_id,0L);  // temporary until sig is assigned in setToken()
	}

	/**
	 * Decrypts a user ID value that was encrypted with encryptId().
	 * 
	 * Reverses the one-time pad encryption by:
	 * 1. Converting each pair of hex characters to an integer
	 * 2. XORing with a pseudo-random value seeded by sig
	 * 3. Converting to bytes and building the output string
	 * 
	 * Note: Decryption is only possible while the User entity is persisted in the database
	 * (typically 1 day for expired entities).
	 * 
	 * @param enc the encrypted hex-encoded string
	 * @param sig the seed value for Random (user's @Id)
	 * @return the decrypted user ID, or error message if decryption fails
	 */
	static String decryptId(String enc, long sig) {
		try {
			int length = enc.length()/2;
			byte[] output = new byte[length];
			Random rand = new Random(sig);
			for (int i=0;i<length;i++) {
				int a = rand.nextInt(ENCRYPT_RANDOM_RANGE);
				int b = Integer.parseInt(enc.substring(2*i, 2*i+2),16);
				Integer xor = a^b;
				output[i] = xor.byteValue(); 
			}
			return new String(output,"UTF-8");	
		} catch (Exception e) {
			return e.toString() + " " + e.getMessage();
		}
	}

	static long encode(long encrypt) {
		/*
		 * Weak encoding of the expiration Date takes place in 3 steps using 4 groups of 3 hexdigits (each hexdigit represents 4 bits):
		 * 1 - using the last 3 hex digits as an initialization vector (iv), each group is XORed with the group to its right (after modification). The iv is unmodified.
		 * 2 - the modified long integer is XORed with hexdigits 4-12 of a long resulting from new Random(iv)
		 * 3 - the resulting long is XORed with itself after shifting to the left by 3 hexdigits (12 bits) and masking all but 12 digits
		 * Decoding is done by repeating the exact same operation as encoding
		 */
	
		try {
			long mask = 0xfffL;
			long iv = encrypt & mask;
			long code;
			for (int i=0;i<3;i++) {  // step 1
				code = (mask & encrypt) << 12;
				encrypt = encrypt ^ code;
				mask = mask << 12;
			}
			mask = 0xfffffffff000L;
			encrypt = encrypt ^ (new Random(iv).nextLong() & mask); // step 2
			mask = 0xfffffffffL;
			code = (encrypt & mask) << 12;
			encrypt = encrypt ^ code;  // step 3
		} catch (Exception e) {
			return 0;
		}
		return encrypt;
	}

	/**
	 * Encrypts a user ID value using a one-time pad algorithm.
	 * 
	 * Creates weak but privacy-protecting encryption by:
	 * 1. Generating pseudo-random integers (0-127) seeded by sig
	 * 2. XORing each input byte with a random value
	 * 3. Converting to two-character hexadecimal for storage
	 * 
	 * The encrypted output length is 2x the input length (each byte becomes 2 hex chars).
	 * Decryption is only possible while the User entity exists in the database.
	 * 
	 * @param id the user ID string to encrypt (encoded as UTF-8)
	 * @param sig the seed value for Random (typically user's datastore @Id)
	 * @return hex-encoded encrypted string, or null if encryption fails
	 */
	static String encryptId(String id, long sig) {
		try {
			byte[] input = id.getBytes("UTF-8");
			String output = "";
			Random rand = new Random(sig);
			for (int i=0;i<input.length;i++) {
				int a = rand.nextInt(ENCRYPT_RANDOM_RANGE);
				int b = (int) input[i];
				int xor = a^b;
				output += (xor<16?"0":"") + Integer.toHexString(a^b);  // retains leading zero, if present
			}
			return output;
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Gets the hashed user identifier for secure data linkage.
	 * 
	 * Anonymous users return the hash of their encrypted ID.
	 * LTI users return the hash of their user_id (platform + userId).
	 * 
	 * @return the hashed user identifier
	 */
	String getHashedId() {
		return (isAnonymous()?Util.hashId(encryptedId):hashedId);
	}

	/**
	 * Gets the decrypted user identifier.
	 * 
	 * @return the decrypted user ID string
	 */
	String getId() {
		return decryptId(encryptedId,sig);
	}
	
	/**
	 * Gets the string representation of this user's unique signature.
	 * 
	 * For anonymous users, returns the encoded expiration timestamp.
	 * For LTI users, returns the datastore-assigned user ID.
	 * 
	 * @return string version of the user's signature (datastore @Id)
	 */
	String getTokenSignature() {
		if (this.isAnonymous()) return String.valueOf(sig);
		else {
			if (sig==null) setToken();
			return String.valueOf(sig);
		}
	}

	/**
	 * Gets the assignment ID associated with this user.
	 * 
	 * @return the assignment ID (0L if not set)
	 */
	long getAssignmentId() {
		return assignmentId;
	}

	/**
	 * Retrieves a User by signature with default 90-minute expiration window.
	 * 
	 * @param sig the user's signature (string version of datastore @Id)
	 * @return the User if found and not expired, null otherwise
	 * @see #getUser(String, int)
	 */
	static User getUser(String sig) {
		return getUser(sig, DEFAULT_EXPIRATION_MINUTES);
	}

	/**
	 * Retrieves a User by signature with custom expiration window.
	 * 
	 * Checks if the user exists in the datastore and hasn't expired.
	 * If found, extends the expiration date and persists the change.
	 * Falls back to checking anonymous user tokens if not found as LTI user.
	 * 
	 * Maximum expiration is capped at 500 minutes to prevent abuse.
	 * A 5-minute grace period is added to the requested expiration.
	 * 
	 * @param sig the user's signature (string version of datastore @Id)
	 * @param minutesRequired the requested expiration window in minutes
	 * @return the User if found and not expired, null otherwise
	 */
	static User getUser(String sig, int minutesRequired) {
		if (sig==null) return null;
		if (minutesRequired > MAX_EXPIRATION_MINUTES) minutesRequired = MAX_EXPIRATION_MINUTES;
		Date now = new Date();
		Date expires = new Date(now.getTime() + (minutesRequired + GRACE_PERIOD_MINUTES) * MILLIS_PER_MINUTE);
		
		try {  // try to find the LTI User entity in the datastore
			User user = ofy().load().type(User.class).id(Long.parseLong(sig)).safe();
			if (user.exp.before(now)) return null; // entity has expired
			else { // extend the exp time
				user.exp = expires;
				ofy().save().entity(user);
			}
			return user;
		} catch (Exception e) {  // try to process an anonymous user
			Long millis = Long.parseLong(sig);
			Date exp = new Date(millis);
			if (exp.after(now) && exp.before(expires)) return new User();
		}
		return null;   	
	}

	/**
	 * Checks if this user is an administrator.
	 * 
	 * @return true if user has administrator role or is ChemVantage admin
	 */
	boolean isAdministrator() {
		return (roles & ROLE_ADMINISTRATOR)>0 || isChemVantageAdmin();		
	}

	/**
	 * Checks if this user is an anonymous (unauthenticated) session.
	 * 
	 * @return true if user has "anonymous" prefix in encrypted ID
	 */
	boolean isAnonymous() {
		return encryptedId.contains(ANONYMOUS_PREFIX);
	}

	/**
	 * Checks if this user is a ChemVantage super-administrator.
	 * 
	 * @return true if user has ChemVantage admin role
	 */
	boolean isChemVantageAdmin() {
		return (roles & ROLE_CHEMVANTAGE_ADMIN)>0;
	}
	
	/**
	 * Checks if this user can edit questions and content.
	 * 
	 * @return true if user has contributor role or higher
	 */
	boolean isEditor() {
		return (roles & ROLE_CONTRIBUTOR)>0 || isChemVantageAdmin();
	}

	/**
	 * Checks if this user is an instructor.
	 * 
	 * @return true if user has instructor role or is administrator
	 */
	boolean isInstructor() {
		return (roles & ROLE_INSTRUCTOR)>0 || isAdministrator();
	}

	/**
	 * Checks if this user has a premium subscription.
	 * 
	 * Returns true if user is instructor/admin or has active PremiumUser entry.
	 * 
	 * @return true if user's premium subscription is active
	 */
	boolean isPremium() {
		try {
			if (isInstructor() || isTeachingAssistant()) return true;
			PremiumUser pu = ofy().load().key(key(PremiumUser.class,this.hashedId)).safe();
			if (pu.exp.after(new Date())) return true;
			return false;
		} catch (Exception e) {
			return false; // not found
		}
	}

	/**
	 * Checks if this user is a teaching assistant.
	 * 
	 * @return true if user has TA role or is instructor
	 */
	boolean isTeachingAssistant() {    
		return (roles & ROLE_TEACHING_ASSISTANT)>0 || isInstructor();
	}

	/**
	 * Checks if this user can contribute questions.
	 * 
	 * @return true if user has contributor role
	 */
	boolean isContributor() {
		return (roles & ROLE_CONTRIBUTOR)>0;
	}

	/**
	 * Sets or removes the administrator role.
	 * 
	 * @param makeAdmin true to grant admin role, false to remove it
	 * @return true if role state was changed, false if already in that state
	 */
	boolean setIsAdministrator(boolean makeAdmin) {
		if (isAdministrator() ^ makeAdmin) {
			roles = roles | (makeAdmin?ROLE_ADMINISTRATOR:ROLE_BITMASK^ROLE_ADMINISTRATOR);
			return true;
		}
		else return false;
	}

	/**
	 * Sets or removes the ChemVantage administrator role.
	 * 
	 * Also calls setToken() to persist changes immediately.
	 * 
	 * @param makeAdmin true to grant role, false to remove it
	 * @return true if role state was changed, false if already in that state
	 */
	boolean setIsChemVantageAdmin(boolean makeAdmin) {
		if (isChemVantageAdmin() ^ makeAdmin) {
			roles = roles | (makeAdmin?ROLE_CHEMVANTAGE_ADMIN:ROLE_BITMASK^ROLE_CHEMVANTAGE_ADMIN);
			setToken();
			return true;
		}
		else return false;
	}

	/**
	 * Sets or removes the instructor role.
	 * 
	 * @param makeInstructor true to grant role, false to remove it
	 * @return true if role state was changed, false if already in that state
	 */
	boolean setIsInstructor(boolean makeInstructor) {
		if (isInstructor() ^ makeInstructor) {
			roles = roles | (makeInstructor?ROLE_INSTRUCTOR:ROLE_BITMASK^ROLE_INSTRUCTOR);
			return true;
		}
		else return false;		
	}

	/**
	 * Sets or removes the teaching assistant role.
	 * 
	 * @param makeTeachingAssistant true to grant role, false to remove it
	 * @return true if role state was changed, false if already in that state
	 */
	boolean setIsTeachingAssistant(boolean makeTeachingAssistant) {
		if (isTeachingAssistant() ^ makeTeachingAssistant) {
			roles = roles | (makeTeachingAssistant?ROLE_TEACHING_ASSISTANT:ROLE_BITMASK^ROLE_TEACHING_ASSISTANT);
			return true;
		}
		else return false;
	}

	/**
	 * Sets the assignment ID for this user (LTI Advantage grade services).
	 * 
	 * Triggers token persistence via setToken().
	 * 
	 * @param assignmentId the ID of the assignment associated with this user
	 */
	void setAssignment(long assignmentId) {
		this.assignmentId = assignmentId;
		setToken();
	}
	
	/**
	 * Persists this user to the datastore (for LTI users only).
	 * 
	 * Anonymous users are never saved.
	 * LTI users are checked for existing entries and reused if found,
	 * otherwise a new user is created with an allocated signature ID.
	 * 
	 * The encrypted ID is re-encrypted with the final sig value.
	 * Expired users (exp < now) are automatically deleted from the datastore.
	 */
	void setToken() {
		if (this.isAnonymous()) return;  // never save anonymous users to the database
		else { // check to see if this user/assignment combination already exists
			try {  // check to see if there is a current user in the database
				User u = ofy().load().type(User.class).filter("hashedId",this.hashedId).filter("assignmentId",this.assignmentId).first().safe();
				this.sig = u.sig;  // this is a current user; just use it
				this.encryptedId = u.encryptedId;
				ofy().save().entity(this);
			} catch (Exception e) {  // store a new user
				this.sig = ofy().factory().allocateId(User.class).getId();
				this.encryptedId = encryptId(decryptId(this.encryptedId,0L),sig);  // change the temporary encrypted value to one matching sig
				ofy().save().entity(this).now();	
			}
		}
		// Clean up expired user sessions
		List<User> expiredUsers = ofy().load().type(User.class).filter("exp <",new Date()).list();
		ofy().delete().entities(expiredUsers);
	}

}